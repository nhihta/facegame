<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>AR Darts — Front Cam + Lip Trigger (Fixed getUserMedia)</title>
  <style>
    :root { --glass: rgba(255,255,255,.1); --line: rgba(255,255,255,.2); }
    html, body { margin:0; padding:0; height:100%; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { position:relative; width:100%; height:100%; overflow:hidden; }

    /* Front camera feed (selfie) — mirror for natural interaction */
    video#cam { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1); background:#111; }

    /* Drawing overlay */
    canvas#overlay { position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }

    .topbar { position:absolute; top:0; left:0; right:0; display:flex; align-items:center; justify-content:space-between; gap:.5rem; padding:.6rem .8rem; color:#fff; background:linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0)); z-index:2; }
    .score { font-weight:800; font-size:1.1rem; }
    .chips { display:flex; gap:.35rem; flex-wrap:wrap; }
    .chip { background:var(--glass); border:1px solid var(--line); border-radius:999px; padding:.25rem .5rem; font-size:.9rem; }

    .hud { position:absolute; left:0; right:0; bottom:0; display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; padding:.75rem; background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0)); z-index:2; }
    .btn { appearance:none; border:1px solid var(--line); background:var(--glass); color:#fff; padding:.55rem .85rem; border-radius:12px; font-weight:700; cursor:pointer; backdrop-filter: blur(4px); }
    .btn:disabled { opacity:.5; cursor:not-allowed; }

    .banner { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:#fff; text-align:center; background:rgba(0,0,0,.45); border:1px solid var(--line); padding:12px 16px; border-radius:12px; z-index:2; max-width:min(92vw,640px); }

    .centerDot { position:absolute; top:50%; left:50%; width:8px; height:8px; transform:translate(-50%, -50%); border-radius:50%; background:rgba(255,255,255,.35); }
  </style>
</head>
<body>
  <div id="app">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div class="centerDot" aria-hidden="true"></div>

    <div class="topbar">
      <div class="score" id="score">Điểm: 0</div>
      <div class="chips">
        <span class="chip" id="modeChip">Chưa bật camera</span>
        <span class="chip" id="handChip">Tay: —</span>
        <span class="chip" id="faceChip">Miệng: —</span>
        <span class="chip" id="fpsChip">FPS: —</span>
        <span class="chip" id="boardChip">Bia: cố định</span>
      </div>
    </div>

    <div class="hud">
      <button class="btn" id="startBtn">Bật camera trước</button>
      <button class="btn" id="placeBtn">Đặt/di chuyển bia</button>
      <button class="btn" id="sizeMinus">Bia nhỏ</button>
      <button class="btn" id="sizePlus">Bia to</button>
      <button class="btn" id="debugBtn">Bật debug</button>
      <button class="btn" id="resetBtn">Reset điểm</button>
    </div>

    <div class="banner" id="helpBanner">Nếu không thấy camera, hãy mở qua HTTPS (https://) hoặc http://localhost và cấp quyền camera. Sau đó bấm "Bật camera trước".</div>
  </div>

  <!-- MediaPipe Hands + FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>

  <script>
  const $ = (s) => document.querySelector(s);
  const video = $('#cam');
  const canvas = $('#overlay');
  const ctx = canvas.getContext('2d');
  let W=0,H=0; const resize = () => { canvas.width=W=innerWidth; canvas.height=H=innerHeight; drawBoard(); }; resize(); addEventListener('resize', resize);

  const scoreEl=$('#score'), modeChip=$('#modeChip'), handChip=$('#handChip'), faceChip=$('#faceChip'), fpsChip=$('#fpsChip'), boardChip=$('#boardChip');
  const startBtn=$('#startBtn'), placeBtn=$('#placeBtn'), sizeMinus=$('#sizeMinus'), sizePlus=$('#sizePlus'), debugBtn=$('#debugBtn'), resetBtn=$('#resetBtn');
  const helpBanner=$('#helpBanner');

  // Ensure flags for iOS Safari
  video.setAttribute('playsinline','');
  video.setAttribute('muted','');
  video.muted = true;

  let totalScore=0, debug=false, placing=false;
  const MIRROR = true; // mirrored selfie display

  // ===== Dartboard (position + geometry) =====
  const board = { cx: W/2, cy: H/2, R: Math.min(W,H)*0.38, rInnerBull:.05, rBull:.09, rTripleIn:.53, rTripleOut:.59, rDoubleIn:.88, rDoubleOut:.94 };
  const SEG=[20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];

  placeBtn.addEventListener('click',()=>{ placing=!placing; boardChip.textContent = placing? 'Bia: đang đặt' : 'Bia: cố định'; });
  addEventListener('click',(e)=>{ if(!placing) return; const r=canvas.getBoundingClientRect(); board.cx=(e.clientX-r.left)*(canvas.width/r.width); board.cy=(e.clientY-r.top)*(canvas.height/r.height); placing=false; boardChip.textContent='Bia: cố định'; drawBoard(); });
  sizeMinus.addEventListener('click',()=>{ board.R=Math.max(40, board.R*0.9); drawBoard(); });
  sizePlus.addEventListener('click',()=>{ board.R=Math.min(Math.min(W,H)*0.48, board.R*1.1); drawBoard(); });

  // ===== Camera =====
  startBtn.addEventListener('click', startCamera);
  async function startCamera(){
    try{
      if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
        throw new Error('Trình duyệt không hỗ trợ navigator.mediaDevices.getUserMedia');
      }
      if (!isSecureContext && location.hostname !== 'localhost') {
        throw new Error('Trang không chạy trong bối cảnh an toàn (HTTPS). Hãy dùng https:// hoặc http://localhost');
      }
      modeChip.textContent='Đang xin quyền camera…'; helpBanner.style.display='none';

      const constraintsPrimary = { video:{ facingMode:{ ideal:'user' }, width:{ ideal:1280 }, height:{ ideal:720 }}, audio:false };
      const constraintsFallback = { video:true, audio:false };

      let stream;
      try { stream = await navigator.mediaDevices.getUserMedia(constraintsPrimary); }
      catch (e1) {
        console.warn('Primary constraints failed, retrying with fallback', e1);
        stream = await navigator.mediaDevices.getUserMedia(constraintsFallback);
      }

      video.srcObject = stream;
      await video.play();
      modeChip.textContent='Camera trước đã bật';

      if (!handsInited) initHands();
      if (!faceInited) initFace();

      loop();
    }catch(err){
      console.error('Camera error:', err);
      let msg = 'Không bật được camera. ';
      if (err && err.name === 'NotAllowedError') msg += 'Bạn đã từ chối quyền camera. Vào cài đặt trình duyệt và cấp lại quyền.';
      else if (err && err.name === 'NotFoundError') msg += 'Không tìm thấy camera. Hãy kiểm tra thiết bị hoặc đóng ứng dụng khác đang dùng camera.';
      else if (err && err.message) msg += err.message;
      else msg += 'Hãy dùng Chrome/Edge mới, chạy qua HTTPS hoặc http://localhost, và cấp quyền.';
      modeChip.textContent = msg;
      helpBanner.textContent = msg;
      helpBanner.style.display='block';
    }
  }

  // ===== MediaPipe Hands (ngón trỏ) =====
  let hands=null, handsInited=false; const handState={ lastTip:null, visible:false };
  function initHands(){
    hands = new Hands({ locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:.6, minTrackingConfidence:.6 });
    hands.onResults(onHand);
    handsInited=true;
  }

  function toCanvas(p){ const x=p.x*W, y=p.y*H; return MIRROR? {x:W-x, y}:{x,y}; }

  // ===== MediaPipe FaceMesh (khẩu hình) =====
  let faceMesh=null, faceInited=false; const faceState={ mouthAR:0, lastShootT:0 };
  function initFace(){
    faceMesh = new FaceMesh.FaceMesh({ locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:false, minDetectionConfidence:.5, minTrackingConfidence:.5 });
    faceMesh.onResults(onFace);
    faceInited=true;
  }

  // Mouth Aspect Ratio (MAR)
  function computeMAR(lm){
    const U=lm[13], L=lm[14]; // môi trên / dưới (trung tâm)
    const LE=lm[33], RE=lm[263]; // đuôi mắt trái/phải
    const mouth = Math.hypot(U.x-L.x, U.y-L.y);
    const eye = Math.hypot(LE.x-RE.x, LE.y-RE.y) + 1e-6;
    return mouth/eye; // ~0.02 (khép) → >0.08 (mở rộng)
  }

  let lastFrameT=performance.now();
  async function loop(){
    if(!video.videoWidth){ requestAnimationFrame(loop); return; }
    resize();
    const now=performance.now(); const dt=Math.max(1, now-lastFrameT)/1000; lastFrameT=now; fpsChip.textContent=`FPS: ${Math.round(1/dt)}`;

    await Promise.all([
      hands.send({ image: video }),
      faceMesh.send({ image: video })
    ]);

    requestAnimationFrame(loop);
  }

  function onHand(res){
    if(res.multiHandLandmarks && res.multiHandLandmarks.length){
      const lm=res.multiHandLandmarks[0]; handState.visible=true; handChip.textContent='Tay: thấy';
      handState.lastTip = toCanvas(lm[8]);
    } else { handState.visible=false; handChip.textContent='Tay: không thấy'; }
  }

  function onFace(res){
    ctx.clearRect(0,0,W,H); vignette(); drawBoard();

    if(res.multiFaceLandmarks && res.multiFaceLandmarks.length){
      const lm = res.multiFaceLandmarks[0];
      faceState.mouthAR = computeMAR(lm);
      faceChip.textContent = `Miệng: ${faceState.mouthAR.toFixed(2)}`;

      const TH = 0.085; // ngưỡng mở miệng
      const COOLDOWN = 600; // ms
      if(faceState.mouthAR > TH && performance.now() - faceState.lastShootT > COOLDOWN){
        faceState.lastShootT = performance.now();
        triggerShoot();
      }

      if(debug){ drawFaceDebug(lm); }
    } else {
      faceChip.textContent='Miệng: —';
    }

    if(handState.lastTip){
      ctx.beginPath(); ctx.arc(handState.lastTip.x, handState.lastTip.y, 6, 0, Math.PI*2); ctx.fillStyle='rgba(0,255,0,.7)'; ctx.fill();
    }
  }

  function drawFaceDebug(lm){
    const pts=[13,14,33,263];
    ctx.save(); ctx.fillStyle='rgba(255,0,200,.5)';
    pts.forEach(i=>{ const p=toCanvas(lm[i]); ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2); ctx.fill(); });
    ctx.restore();
  }

  function triggerShoot(){
    if(!handState.visible || !handState.lastTip){ modeChip.textContent='Không thấy tay để bắn'; return; }
    const p = handState.lastTip; // dùng điểm ảnh hiện tại của ngón trỏ
    const hit = clampToBoard(p);
    registerThrow(p, hit);
  }

  function clampToBoard(p){
    const dx=p.x-board.cx, dy=p.y-board.cy; const d=Math.hypot(dx,dy); const R=board.rDoubleOut*board.R; if(d<=R) return p; const k=R/d; return {x:board.cx+dx*k, y:board.cy+dy*k};
  }

  // ===== Board + scoring =====
  function drawBoard(){
    const cx=board.cx, cy=board.cy, R=board.R;
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.6)'; ctx.shadowBlur=20;
    circle(cx,cy,R,'rgba(30,30,30,.85)');
    ring(cx,cy,board.rDoubleIn*R, board.rDoubleOut*R, 'rgba(255,255,255,.08)');
    ring(cx,cy,board.rTripleIn*R, board.rTripleOut*R, 'rgba(255,255,255,.08)');
    ring(cx,cy,board.rInnerBull*R, board.rBull*R, 'rgba(0,0,0,0)', '#ddd');
    circle(cx,cy,board.rInnerBull*R, 'rgba(255,255,255,.9)');
    ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.lineWidth=1.2;
    for(let i=0;i<20;i++){ const a=(i/20)*Math.PI*2 - Math.PI/2; ctx.beginPath(); ctx.moveTo(cx+Math.cos(a)*board.rTripleOut*R, cy+Math.sin(a)*board.rTripleOut*R); ctx.lineTo(cx+Math.cos(a)*board.rDoubleOut*R, cy+Math.sin(a)*board.rDoubleOut*R); ctx.stroke(); }
    ctx.restore();
  }
  function circle(x,y,r,fill){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); if(fill){ ctx.fillStyle=fill; ctx.fill(); } }
  function ring(x,y,r1,r2,fill,stroke){ ctx.beginPath(); ctx.arc(x,y,r2,0,Math.PI*2); ctx.arc(x,y,r1,0,Math.PI*2,true); ctx.closePath(); if(fill){ ctx.fillStyle=fill; ctx.fill(); } if(stroke){ ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.stroke(); } }

  function polarScore(x,y){
    const cx=board.cx, cy=board.cy, R=board.R; const dx=x-cx, dy=y-cy; const r=Math.hypot(dx,dy);
    if(r>board.rDoubleOut*R) return {score:0, ring:'MISS', seg:0};
    if(r<=board.rInnerBull*R) return {score:50, ring:'INNER BULL', seg:25};
    if(r<=board.rBull*R) return {score:25, ring:'OUTER BULL', seg:25};
    let ang=Math.atan2(dy,dx); let deg=ang*180/Math.PI; let fromTop=(90+deg+360)%360; const segIndex=Math.floor((fromTop+9)/18)%20; const base=SEG[segIndex];
    let mult=1, ring='SINGLE';
    if(r>=board.rDoubleIn*R && r<=board.rDoubleOut*R){ mult=2; ring='DOUBLE'; }
    else if(r>=board.rTripleIn*R && r<=board.rTripleOut*R){ mult=3; ring='TRIPLE'; }
    return { score: base*mult, ring, seg: base };
  }

  function registerThrow(p0, pHit){
    const res = polarScore(pHit.x, pHit.y); totalScore += res.score; scoreEl.textContent=`Điểm: ${totalScore}`; modeChip.textContent = `${res.ring} ${res.seg||''} → +${res.score}`.trim();
    drawImpact(p0, pHit);
  }

  function drawImpact(p0, p1){
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.strokeStyle='rgba(255,255,255,.6)'; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.arc(p1.x,p1.y,12,0,Math.PI*2); ctx.fillStyle='rgba(0,200,255,.9)'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2; ctx.stroke();
  }

  function vignette(){
    const g=ctx.createRadialGradient(W/2,H/2,Math.max(W,H)*.1, W/2,H/2,Math.max(W,H)*.7);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,.25)'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  }

  // Draw a board initially so user always sees it
  drawBoard();
  </script>
</body>
</html>

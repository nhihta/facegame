<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>AR Darts — Rear Camera Hand-Throw</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { position: relative; width: 100%; height: 100%; overflow: hidden; }

    video#cam { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); /* mirror for easier aiming; remove if you prefer non-mirrored */ }

    canvas#overlay { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    .hud {
      position: absolute; left: 0; right: 0; bottom: 0; display: flex; flex-wrap: wrap; gap: .5rem; padding: .75rem; justify-content: center; pointer-events: auto;
      background: linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));
    }
    .hud .btn {
      appearance: none; border: 1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.1); color: #fff; padding: .55rem .8rem; border-radius: 12px; font-weight: 600; cursor: pointer; backdrop-filter: blur(4px);
    }
    .hud .btn:disabled { opacity: .5; cursor: not-allowed; }

    .topbar { position: absolute; top: 0; left: 0; right: 0; display: flex; align-items: center; justify-content: space-between; padding: .65rem .8rem; color: #fff; gap: .5rem; background: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0)); }
    .score { font-size: 1.1rem; font-weight: 700; }
    .status { font-size: .9rem; opacity: .9; }

    .chip { background: rgba(255,255,255,.12); padding: .3rem .55rem; border-radius: 999px; border: 1px solid rgba(255,255,255,.2); }

    /* Optional: place a subtle crosshair at center */
    .centerDot { position: absolute; top: 50%; left: 50%; width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,.3); transform: translate(-50%, -50%); }

    /* Helper for small screens */
    @media (max-width: 420px) { .score { font-size: 1rem; } .status{ display:none;} }
  </style>
</head>
<body>
  <div id="app">
    <video id="cam" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
    <div class="centerDot" aria-hidden="true"></div>
    <div class="topbar">
      <div class="score" id="score">Điểm: 0</div>
      <div class="status"><span class="chip" id="modeChip">Chưa bật camera</span> <span class="chip" id="handChip">Tay: —</span> <span class="chip" id="fpsChip">FPS: —</span></div>
    </div>
    <div class="hud">
      <button class="btn" id="startBtn">Bật camera sau</button>
      <button class="btn" id="throwBtn">Chạm để ném (dự phòng)</button>
      <button class="btn" id="debugBtn">Bật debug tay</button>
      <button class="btn" id="resetBtn">Reset điểm</button>
    </div>
  </div>

  <!-- MediaPipe Hands (no TF.js required) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>

  <script>
  // ======= Utility helpers =======
  const $ = (sel) => document.querySelector(sel);
  const video = $('#cam');
  const canvas = $('#overlay');
  const ctx = canvas.getContext('2d');
  const scoreEl = $('#score');
  const modeChip = $('#modeChip');
  const handChip = $('#handChip');
  const fpsChip = $('#fpsChip');
  const startBtn = $('#startBtn');
  const throwBtn = $('#throwBtn');
  const resetBtn = $('#resetBtn');
  const debugBtn = $('#debugBtn');

  let W = 0, H = 0, rafId = null;
  let debug = false;
  let totalScore = 0;

  // Dartboard geometry (relative to boardRadius)
  const board = {
    cx: 0, cy: 0, R: 0,
    rBull: 0.09,   // outer bull radius (25)
    rInnerBull: 0.05, // inner bull (50)
    rTripleIn: 0.53, rTripleOut: 0.59,
    rDoubleIn: 0.88, rDoubleOut: 0.94,
  };

  // Standard dartboard numbering clockwise from top (20 at 12 o'clock)
  const SEG = [20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];

  function resize() {
    const { clientWidth, clientHeight } = document.body;
    canvas.width = W = clientWidth; canvas.height = H = clientHeight;
    // Board centered, radius 40% of min dimension
    board.cx = W / 2; board.cy = H / 2; board.R = Math.min(W, H) * 0.4;
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  // ======= Camera =======
  async function startCamera() {
    try {
      modeChip.textContent = 'Đang xin quyền camera…';
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      modeChip.textContent = 'Camera sau đã bật';
      loop();
    } catch (err) {
      console.error(err);
      modeChip.textContent = 'Không bật được camera';
      alert('Không truy cập được camera. Hãy dùng HTTPS và cho phép quyền sử dụng camera.');
    }
  }

  startBtn.addEventListener('click', startCamera);

  // ======= MediaPipe Hands setup =======
  let hands = null;
  const handState = {
    lastT: 0,
    lastIndex: null, // previous fingertip pos {x,y}
    lastOpen: 0,
    speed: 0,
    open: 0,
    visible: false,
  };

  function makeHands() {
    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });
    hands.onResults(onHandResults);
  }
  makeHands();

  // Convert normalized landmark to canvas coords
  function toCanvasXY(landmark) {
    return { x: landmark.x * W, y: landmark.y * H };
  }

  // Compute hand openness (avg tip distance to palm, normalized by hand size)
  function computeOpenness(landmarks) {
    const wrist = landmarks[0];
    const indexMCP = landmarks[5]; // base of index
    const pinkyMCP = landmarks[17];
    const palmCx = (wrist.x + indexMCP.x + pinkyMCP.x) / 3;
    const palmCy = (wrist.y + indexMCP.y + pinkyMCP.y) / 3;
    const palmRef = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y) + 1e-6;
    const tips = [8,12,16,20];
    let acc = 0;
    for (const i of tips) {
      const d = Math.hypot(landmarks[i].x - palmCx, landmarks[i].y - palmCy);
      acc += d / palmRef;
    }
    return acc / tips.length; // ~0.4 (closed) → ~1.2 (open)
  }

  let lastFrameTime = performance.now();
  function onHandResults(res) {
    ctx.clearRect(0,0,W,H);
    drawVideoShadow();
    drawDartboard();

    const now = performance.now();
    const dt = Math.max(1, now - lastFrameTime) / 1000;
    lastFrameTime = now;
    fpsChip.textContent = `FPS: ${Math.round(1/dt)}`;

    if (res.multiHandLandmarks && res.multiHandLandmarks.length) {
      const lm = res.multiHandLandmarks[0];
      handState.visible = true;

      const open = computeOpenness(lm);
      const tip = toCanvasXY(lm[8]); // index fingertip

      // fingertip speed in px/s
      let speed = 0;
      if (handState.lastIndex) {
        const dx = tip.x - handState.lastIndex.x;
        const dy = tip.y - handState.lastIndex.y;
        speed = Math.hypot(dx, dy) / dt;
      }

      // Detect a "release": sudden increase in openness + high fingertip speed
      const openDelta = open - handState.lastOpen;
      const release = (open > 0.95 && openDelta > 0.15 && speed > 600);

      if (release) {
        // Hit where the fingertip points at release
        registerThrow(tip.x, tip.y);
      }

      // Draw debug
      if (debug) {
        drawLandmarksOnCanvas(lm);
        ctx.fillStyle = '#fff';
        ctx.font = '12px system-ui';
        ctx.fillText(`open=${open.toFixed(2)} speed=${Math.round(speed)}px/s`, 8, 16);
        ctx.beginPath(); ctx.arc(tip.x, tip.y, 6, 0, Math.PI*2); ctx.fillStyle = 'rgba(0,255,0,.6)'; ctx.fill();
      }

      handState.lastIndex = tip;
      handState.lastOpen = open;
      handChip.textContent = 'Tay: Đang theo dõi';
    } else {
      handState.visible = false;
      handChip.textContent = 'Tay: Không thấy';
      drawDartboard();
    }
  }

  function drawLandmarksOnCanvas(landmarks) {
    // Minimal draw (avoid external drawing_utils heavy funcs)
    ctx.save();
    ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,255,255,.8)'; ctx.fillStyle = 'rgba(0,255,255,.3)';
    for (const p of landmarks) {
      const {x,y} = toCanvasXY(p);
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // ======= Main loop: feed frames to MediaPipe =======
  async function loop() {
    if (!video.videoWidth || !video.videoHeight) {
      rafId = requestAnimationFrame(loop); return;
    }
    // Keep canvas matched to visual size (covers viewport)
    resize();
    await hands.send({ image: video });
    rafId = requestAnimationFrame(loop);
  }

  // ======= Drawing =======
  function drawVideoShadow() {
    // Optional vignette edges for depth feel
    const g = ctx.createRadialGradient(W/2, H/2, Math.max(W,H)*0.1, W/2, H/2, Math.max(W,H)*0.7);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,.25)');
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }

  function drawDartboard() {
    const cx = board.cx, cy = board.cy, R = board.R;
    // Rings
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,.6)'; ctx.shadowBlur = 20;

    // Base board
    ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.fillStyle = 'rgba(30,30,30,.85)'; ctx.fill();

    // Double ring area
    ring(cx,cy,board.rDoubleIn*R, board.rDoubleOut*R, 'rgba(255,255,255,.08)');
    // Triple ring area
    ring(cx,cy,board.rTripleIn*R, board.rTripleOut*R, 'rgba(255,255,255,.08)');
    // Outer bull
    ring(cx,cy,board.rInnerBull*R, board.rBull*R, 'rgba(0,0,0,0)', '#ddd');
    // Inner bull
    ctx.beginPath(); ctx.arc(cx,cy,board.rInnerBull*R,0,Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,.9)'; ctx.fill();

    // Spokes (20 segments)
    ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.lineWidth = 1.2;
    for (let i=0;i<20;i++) {
      const ang = (i/20)*Math.PI*2 - Math.PI/2; // start from top
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(ang)* (board.rTripleOut*R), cy + Math.sin(ang)* (board.rTripleOut*R));
      ctx.lineTo(cx + Math.cos(ang)* (board.rDoubleOut*R), cy + Math.sin(ang)* (board.rDoubleOut*R));
      ctx.stroke();
    }

    ctx.restore();
  }

  function ring(cx,cy,rIn,rOut,fill,stroke) {
    ctx.beginPath();
    ctx.arc(cx,cy,rOut,0,Math.PI*2);
    ctx.arc(cx,cy,rIn,0,Math.PI*2,true);
    ctx.closePath();
    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
  }

  // ======= Scoring =======
  function polarScore(x, y) {
    const cx = board.cx, cy = board.cy, R = board.R;
    const dx = x - cx, dy = y - cy;
    const r = Math.hypot(dx, dy);

    // Outside board
    if (r > board.rDoubleOut*R) return { score: 0, ring: 'MISS', seg: 0 };

    // Bulls
    if (r <= board.rInnerBull*R) return { score: 50, ring: 'INNER BULL', seg: 25 };
    if (r <= board.rBull*R) return { score: 25, ring: 'OUTER BULL', seg: 25 };

    // Angle: 0 at top, clockwise positive
    let ang = Math.atan2(dy, dx); // -π..π, 0 at +x
    let deg = (ang * 180 / Math.PI);
    let fromTop = (90 + deg + 360) % 360; // 0 at 12 o'clock
    const segIndex = Math.floor((fromTop + 9) / 18) % 20; // 18° per segment
    const base = SEG[segIndex];

    let mult = 1, ringLabel = 'SINGLE';
    if (r >= board.rDoubleIn*R && r <= board.rDoubleOut*R) { mult = 2; ringLabel = 'DOUBLE'; }
    else if (r >= board.rTripleIn*R && r <= board.rTripleOut*R) { mult = 3; ringLabel = 'TRIPLE'; }

    return { score: base * mult, ring: ringLabel, seg: base };
  }

  function registerThrow(x, y) {
    // Visual effect: small marker + line to center
    const res = polarScore(x,y);
    totalScore += res.score;
    scoreEl.textContent = `Điểm: ${totalScore}`;

    // draw impact marker quickly
    ctx.save();
    ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fillStyle = 'rgba(0,200,255,.9)'; ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.6)'; ctx.lineWidth = 2; ctx.stroke();
    ctx.restore();

    // Toast-like status
    modeChip.textContent = `${res.ring} ${res.seg ? res.seg : ''} → +${res.score}`.trim();
  }

  // Fallback: tap anywhere to throw at that point
  document.addEventListener('click', (e) => {
    if (e.target.closest('.btn')) return; // ignore button clicks
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    registerThrow(x,y);
  });
  throwBtn.addEventListener('click', () => {
    // Throw at center for demo
    registerThrow(board.cx, board.cy);
  });

  resetBtn.addEventListener('click', () => { totalScore = 0; scoreEl.textContent = 'Điểm: 0'; });
  debugBtn.addEventListener('click', () => {
    debug = !debug; debugBtn.textContent = debug ? 'Tắt debug tay' : 'Bật debug tay';
  });

  // Accessibility: keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === 'd') debugBtn.click();
    if (e.key === 'r') resetBtn.click();
  });

  // Initial paint
  (function init() { drawDartboard(); })();
  </script>
</body>
</html>
